<Highlight>
  A flexible, framework validation agnostic, type-safe factory for creating
  [Next.JS App Router route
  handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers).
</Highlight>

```tsx
import { object, string, number } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const POST = createSafeRouteHandler(
  {
    authorize: async ({ req }) => {
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
    body: object({
      foo: string,
      bar: number,
    }),
  },
  async (
    {
      auth, // Auth context is inferred from the authorize function
      body, // Body is inferred from the body validation
    },
    req
  ): Promise<Response> => {
    return Response.json({ user: auth.user, body }, { status: 200 })
  }
)
```

- 🔧 Framework validation agnostic, use a validation library of your choice supporting [Standard Schema](https://standardschema.dev/).
- 🧠 Focused functionalities, use only features you want.
- 🧹 Clean and flexible API.
- 🔒 Type-safe.
- 🌱 Dependency free.
- 🪶 Less than 100kB unpacked.

## Install

```sh
npm i @sugardarius/anzen
```

## Framework validation agnostic

By design the factory is framework validation agnostic 🌟. When doing your validations you can use whatever you want as framework validation as long as it implements the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface. You can use your favorite validation library like [Zod](https://zod.dev/) or [decoders](https://decoders.cc/).

```tsx
// (POST) /app/api/races/[id]/route.ts
import { z } from 'zod'
import { object, string, number } from 'decoders'

export const POST = createSafeRouteHandler(
  {
    // `zod` for segments dictionary validation
    segments: { id: z.string() }
    // `decoders` for body object validation
    body: object({
      id: number,
      name: string,
    }),
  },
  async ({ segments, body }) => {
    return Response.json({ segments, body })
  }
)
```

## Synchronous validations

The factory do not supports async validations. As required by the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface we should avoid it. In the context of a route handler it's not necessary.

If you define an async validation then the route handler will throw an error.

## API

Check the API and the available options to configure the factory as you wish.

### Base options

When creating a safe route handler you can use a bunch of options for helping you achieve different tasks 👇🏻

#### `id?: string`

Used for logging in development or when the `debug` option is enabled. You can also use it to add extra logging or monitoring.
By default the id is set to `[unknown:route:handler]`.

```tsx
export const POST = createSafeRouteHandler(
  {
    id: 'my-safe-route-handler',
  },
  async ({ id }) => {
    return Response.json({ id })
  }
)
```

#### `authorize?: AuthFunction<AC>`

Function to use to authorize the request. By default it always authorize the request.
Returns a response when the request is not authorized.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const GET = createSafeRouteHandler(
  {
    authorize: async ({ req, url }) => {
      console.log('url', url)
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
  },
  async ({ auth, body }, req): Promise<Response> => {
    return Response.json({ user: auth.user }, { status: 200 })
  }
)
```

#### `onErrorResponse?: (err: unknown) => Awaitable<Response>`

Callback triggered when the request fails.
By default it returns a simple `500` response and the error is logged into the console.
Use it if your handler use custom errors and you want to manage them properly by returning a proper response.
You can read more about it under the [Error handling](#error-handling) section.

#### `debug?: boolean`

Use this options to enable debug mode. It will add logs in the handler to help you debug the request.
By default it's set to `false` for production builds.
In development builds, it will be `true` if `NODE_ENV` is not set to `production`.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler({ debug: true }, async () => {
  return new Response(null, { status: 200 })
})
```

### Route handler options

You can configure route handler options to validation using a validation library dynamic route segments, URL query parameters, request json body or request form data body 👇🏻

#### `segments?: TSegments`

[Dynamic route segments](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-route-segments) used for the route handler path. By design it will handle if the segments are a `Promise` or not.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="/api/accounts/[accountId]/projects/[projectId]/route.ts"
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
  },
  async ({ segments }) => {
    return Response.json({ segments })
  }
)
```
