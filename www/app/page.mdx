<Announcement className='mt-6 mx-auto' />

<Highlight>
  Fast, flexible, framework validation agnostic, type‚Äësafe factories for
  creating [route
  handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers),
  [page](https://nextjs.org/docs/app/api-reference/file-conventions/page) and
  [layout](https://nextjs.org/docs/app/api-reference/file-conventions/layout)
  Server Component files in Next.js.
</Highlight>

<Tabs defaultValue='route-handler' className='mt-6'>
  <TabsList className='mx-auto max-w-full overflow-x-auto'>
    <TabsTrigger value='route-handler' className='cursor-pointer'>Safe route</TabsTrigger>
    <TabsTrigger value='page-server-component' className='cursor-pointer'>
      Safe page <Badge className="ml-1 px-1 text-[12px] py-0.5 leading-none">new</Badge>
    </TabsTrigger>
    <TabsTrigger value='layout-server-component' className='cursor-pointer'>
      Safe layout <Badge className="ml-1 px-1 text-[12px] py-0.5 leading-none">new</Badge>
    </TabsTrigger>
  </TabsList>
  <TabsContent value='route-handler'>
    ```tsx title="api/authorize"
    import { object, string, number } from 'decoders'
    import { createSafeRouteHandler } from '@sugardarius/anzen'
    import { auth } from '~/lib/auth'

    export const POST = createSafeRouteHandler(
      {
        authorize: async ({ req }) => {
          const session = await auth.getSession(req)
          if (!session) {
            return new Response(null, { status: 401 })
          }

          return { user: session.user }
        },
        body: object({
          foo: string,
          bar: number,
        }),
      },
      async ({ auth, body }, req): Promise<Response> => {
        return Response.json({ user: auth.user, body }, { status: 200 })
      }
    )
    ```

  </TabsContent>
  <TabsContent value='page-server-component'>
    ```tsx title="app/[accountId]/page.tsx"
    import { unauthorized } from 'next/navigation'
    import { string } from 'decoders'
    import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

    import { auth } from '~/lib/auth'
    import { getAccount } from '~/lib/db'

    import { AccountSummary } from '~/components/account-summary'

    export default createSafePageServerComponent(
      {
        authorize: async ({ segments }) => {
          const session = await auth.getSession()
          if (!session) {
            unauthorized()
          }

          return { user: session.user }
        },
        segments: {
          accountId: string,
        },
      }, async ({ auth, segments })  => {
        const account = await getAccount({ id: segments.accountId})
        return <AccountSummary user={auth.user} account={account} />
      }
    )
    ```

  </TabsContent>
  <TabsContent value='layout-server-component'>
    ```tsx title="app/[accountId]/layout.tsx"
    import { notFound, unauthorized } from 'next/navigation'
    import { string } from 'decoders'
    import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

    import { auth } from '~/lib/auth'

    import { AccountHeader } from '~/components/account-header'

    export default createSafeLayoutServerComponent(
      {
        authorize: async ({ segments }) => {
          const session = await auth.getSession()
          if (!session) {
            unauthorized()
          }

          return { user: session.user }
        },
        segments: {
          accountId: string,
        },
      }, async ({ auth, segments, children }) => {
        const account = await getAccount({ id: segments.accountId})
        return (
          <div>
            <AccountHeader user={auth.user} accountId={segments.accountId} />
            {children}
          </div>
        )
      }
    ```

  </TabsContent>
</Tabs>

- üîß Framework validation agnostic, use a validation library of your choice supporting [Standard Schema](https://standardschema.dev/).
- üß† Focused functionalities, use only features you want.
- üßπ Clean and flexible API.
- üîí Type-safe.
- üå± Dependency free. Only [Next.js](https://nextjs.org/) and [TypeScript](https://www.typescriptlang.org/) are required as peer dependencies.
- ü™∂ Lightweight. Less than 140kB unpacked.

## Install

```sh
npm i @sugardarius/anzen
```

## Usage

<Tabs defaultValue='route-handler'>
  <TabsList className="mx-auto max-w-full overflow-x-auto'">
    <TabsTrigger value='route-handler' className='cursor-pointer'>Route.js</TabsTrigger>
    <TabsTrigger value='page-server-components' className='cursor-pointer'>Page.js<Badge className="ml-1 px-1 text-[12px] py-0.5 leading-none">new</Badge></TabsTrigger>
    <TabsTrigger value='layout-server-components' className='cursor-pointer'>Layout.js<Badge className="ml-1 px-1 text-[12px] py-0.5 leading-none">new</Badge></TabsTrigger>
  </TabsList>
  <TabsContent value='route-handler'>

```tsx
import { object, string, number } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const POST = createSafeRouteHandler(
  {
    authorize: async ({ req }) => {
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
    body: object({
      foo: string,
      bar: number,
    }),
  },
  async (
    {
      auth, // Auth context is inferred from the authorize function
      body, // Body is inferred from the body validation
    },
    req
  ): Promise<Response> => {
    return Response.json({ user: auth.user, body }, { status: 200 })
  }
)
```

## Framework validation agnostic

By design the factory is framework validation agnostic üåü. When doing your validations you can use whatever you want as framework validation as long as it implements the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface. You can use your favorite validation library like [Zod](https://zod.dev/), [Validbot](https://valibot.dev/) or [decoders](https://decoders.cc/).

```tsx title="api/races/[id]/route.ts"
import { z } from 'zod'
import { object, string, number } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    // `zod` for segments dictionary validation
    segments: { id: z.string() }
    // `decoders` for body object validation
    body: object({
      id: number,
      name: string,
    }),
  },
  async ({ segments, body }) => {
    return Response.json({ segments, body })
  }
)
```

## Synchronous validations

The factory do not supports async validations. As required by the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface we should avoid it. In the context of a route handler it's not necessary.

If you define an async validation then the route handler will throw an error.

## API

Check the API and the available options to configure the factory as you wish.

### Function signature

```tsx title="node_modules/@sugardarius/anzen/index.d.ts"
import {
  type CreateSafeRouteHandlerOptions,
  type SafeRouteHandlerContext,
  createSafeRouteHandler
} from '@sugardarius/anzen'

/**
 * Returns a Next.js API route handler function.
 */
export const VERB = createSafeRouteHandler(
  /**
   * Options to configure the route handler
   */
  options: CreateSafeRouteHandlerOptions,
  /**
   * The route handler function.
   */
  async (
    /**
     * Context object providing:
     *  auth context
     *  validated segments, search params, body and form data
     */
    ctx: SafeRouteHandlerContext,
    /**
     * Original request
     */
    req: Request
): Promise<Response> => Response.json({}))
```

### Using `NextRequest` type

By default the factory uses the native `Request` type. If you want to use the `NextRequest` type from [Next.js](https://nextjs.org/), you can do it by just using the `NextRequest` type in the factory handler.

```tsx
import { NextRequest } from 'next/server'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    id: 'next/request',
    authorize: async ({
      // Due to `NextRequest` limitations as the req is cloned it's always a `Request`
      req,
    }) => {
      console.log(req)
      return { user: 'John Doe' }
    },
  },
  async (ctx, req: NextRequest) => {
    console.log('pathname', req.nextUrl.pathname)
    return new Response(null, 200)
  }
)
```

### Base options

When creating a safe route handler you can use a bunch of options for helping you achieve different tasks üëáüèª

#### `id?: string`

Used for logging in development or when the `debug` option is enabled. You can also use it to add extra logging or monitoring.
By default the id is set to `[unknown:route:handler]`.

```tsx
export const POST = createSafeRouteHandler(
  {
    id: 'auth/login',
  },
  async ({ id }) => {
    return Response.json({ id })
  }
)
```

#### `onErrorResponse?: (err: unknown) => Awaitable<Response>`

Callback triggered when the request fails.
By default it returns a simple `500` response and the error is logged into the console.
Use it if your handler use custom errors and you want to manage them properly by returning a proper response.
You can read more about it under the [Error handling](#error-handling) section.

#### `debug?: boolean`

Use this options to enable debug mode. It will add logs in the handler to help you debug the request.
By default it's set to `false` for production builds.
In development builds, it will be `true` if `NODE_ENV` is not set to `production`.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler({ debug: true }, async () => {
  return new Response(null, { status: 200 })
})
```

### Route handler options

You can configure route handler options to validation using a validation library dynamic route segments, URL query parameters, request json body or request form data body üëáüèª

#### `authorize?: AuthFunction<AC, TSegments, TSearchParams, TBody, TFormData>`

Function to use to authorize the request. By default it always authorize the request.

Returns a response when the request is not authorized.

The `authorize` function receives validated props (`segments`, `searchParams`, `body`, `formData`) when they are defined, allowing you to use validated data for authorization logic.

<Callout>
  **Note:** Validated props in the `authorize` function are available since
  v2.0.0.
</Callout>

**Parameters:**

- `id: string` - Route handler ID
- `url: URL` - Parsed request URL
- `req: Request` - Cloned request (to avoid side effects and make it consumable)
- `segments?:` - Validated route dynamic segments (if `segments` option is defined)
- `searchParams?:` - Validated search params (if `searchParams` option is defined)
- `body?:` - Validated request body (if `body` option is defined)
- `formData?:` - Validated form data (if `formData` option is defined)

###### Basic authorization

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const GET = createSafeRouteHandler(
  {
    authorize: async ({ req, url }) => {
      console.log('url', url)
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
  },
  async ({ auth }, req): Promise<Response> => {
    return Response.json({ user: auth.user }, { status: 200 })
  }
)
```

###### Authorization with validated segments

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const GET = createSafeRouteHandler(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string(),
    },
    authorize: async ({ segments, req }) => {
      // segments are already validated at this point
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      // Check if user has access to this account
      const hasAccess = await checkAccountAccess(
        session.user.id,
        segments.accountId
      )
      if (!hasAccess) {
        return new Response(null, { status: 403 })
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments }) => {
    return Response.json({ user: auth.user, segments }, { status: 200 })
  }
)
```

###### Authorization with validated body

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    body: z.object({
      apiKey: z.string(),
    }),
    authorize: async ({ body, req }) => {
      // body is already validated at this point
      const isValidKey = await validateApiKey(body.apiKey)
      if (!isValidKey) {
        return new Response(null, { status: 401 })
      }

      return { apiKey: body.apiKey }
    },
  },
  async ({ auth, body }) => {
    return Response.json({ apiKey: auth.apiKey, body }, { status: 200 })
  }
)
```

###### Authorization with all validated props

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const POST = createSafeRouteHandler(
  {
    segments: { accountId: z.string() },
    searchParams: { role: z.string() },
    body: z.object({ action: z.string() }),
    authorize: async ({ segments, searchParams, body, req }) => {
      // All props are validated and available
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      const hasPermission = await checkPermission(
        session.user.id,
        segments.accountId,
        searchParams.role,
        body.action
      )
      if (!hasPermission) {
        return new Response(null, { status: 403 })
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments, searchParams, body }) => {
    return Response.json(
      { user: auth.user, segments, searchParams, body },
      { status: 200 }
    )
  }
)
```

> The original request is cloned from the incoming request to avoid side effects and to make it consumable in the `authorize` function. Due to `NextRequest` limitations, the cloned request is always a `Request` type.

#### `segments?: TSegments`

[Dynamic route segments](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-route-segments) used for the route handler path. By design it will handle if the segments are a `Promise` or not.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="/api/accounts/[accountId]/projects/[projectId]/route.ts"
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
  },
  async ({ segments }) => {
    return Response.json({ segments })
  }
)
```

#### `onSegmentsValidationErrorResponse?: OnValidationErrorResponse`

Callback triggered when dynamic segments validations returned issues. By default it returns a simple `400` response and issues are logged into the console.

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
    onSegmentsValidationErrorResponse: (issues) => {
      return Response.json({ issues }, { status: 400 })
    },
  },
  async ({ segments }) => {
    return Response.json({ segments })
  }
)
```

#### `searchParams?: TSearchParams`

Search params used in the route.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx
import { string, numeric, optional } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    searchParams: {
      query: string,
      page: optional(numeric),
    },
  },
  async ({ searchParams }) => {
    return Response.json({ searchParams })
  }
)
```

#### `onSearchParamsValidationErrorResponse?: OnValidationErrorResponse`

Callback triggered when search params validations returned issues. By default it returns a simple `400` response and issues are logged into the console.

```tsx
import { string, numeric, optional } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    searchParams: {
      query: string,
      page: optional(numeric),
    },
    onSearchParamsValidationErrorResponse: (issues) => {
      return Response.json({ issues }, { status: 400 })
    },
  },
  async ({ searchParams }) => {
    return Response.json({ searchParams })
  }
)
```

#### `body?: TBody`

Request body.

Returns a `405` response if the request method is not `POST`, `PUT` or `PATCH`.

Returns a `415`response if the request does not explicitly set the `Content-Type` to `application/json`.

Please note the body is parsed as JSON, so it must be a valid JSON object. Body shouldn't be used with `formData` at the same time. They are **exclusive**.

Why making the distinction? `formData` is used as a `StandardSchemaDictionary` whereas `body` is used as a `StandardSchemaV1`.

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    body: z.object({
      name: z.string(),
      model: z.string(),
      apiKey: z.string(),
    }),
  },
  async ({ body }) => {
    return Response.json({ body })
  }
)
```

> When validating the body the request is cloned to let you consume the body in the original request (e.g second arguments of handler function).

#### `onBodyValidationErrorResponse?: OnValidationErrorResponse`

Callback triggered when body validation returned issues. By default it returns a simple `400` response and issues are logged into the console.

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    body: z.object({
      name: z.string(),
      model: z.string(),
      apiKey: z.string(),
    }),
    onBodyValidationErrorResponse: (issues) => {
      return Response.json({ issues }, { status: 400 })
    },
  },
  async ({ body }) => {
    return Response.json({ body })
  }
)
```

#### `formData?: TFormData`

Request form data.

Returns a `405` response if the request method is not `POST`, `PUT` or `PATCH`.

Returns a `415`response if the request does not explicitly set the `Content-Type` to `multipart/form-data` or to `application/x-www-form-urlencoded`.

Please note formData shouldn't be used with `body` at the same time. They are **exclusive**.

Why making the distinction? `formData` is used as a `StandardSchemaDictionary` whereas `body` is used as a `StandardSchemaV1`.

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    formData: {
      id: z.string(),
      message: z.string(),
    },
  },
  async ({ formData }) => {
    return Response.json({ formData })
  }
)
```

> When validating the form data the request is cloned to let you consume the form data in the original request (e.g second arguments of handler function).

#### `onFormDataValidationErrorResponse?: OnValidationErrorResponse`

Callback triggered when form data validation returned issues. By default it returns a simple `400` response and issues are logged into the console.

```tsx
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const POST = createSafeRouteHandler(
  {
    formData: {
      id: z.string(),
      message: z.string(),
    },
    onFormDataValidationErrorResponse: (issues) => {
      return Response.json({ issues }, { status: 400 })
    },
  },
  async ({ formData }) => {
    return Response.json({ formData })
  }
)
```

### Error handling

By design the factory will catch any error thrown in the route handler will return a simple response with `500` status.

You can customize the error response if you want to fine tune error response management.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { HttpError, DbUnknownError } from '~/lib/errors'
import { db } from '~/lib/db'

export const GET = createSafeRouteHandler(
  {
    onErrorResponse: async (err: unknown): Promise<Response> => {
      if (err instanceof HttpError) {
        return new Response(err.message, { status: err.status })
      } else if (err instanceof DbUnknownError) {
        return new Response(err.message, { status: err.status })
      }

      return new Response('Internal server error', { status: 500 })
    },
  },
  async (): Promise<Response> => {
    const [data, err] = await db.findUnique({ id: 'liveblocks' })

    if (err) {
      throw new DbUnknownError(err.message, 500)
    }

    if (data === null) {
      throw new HttpError(404)
    }

    return Response.json({ data })
  }
)
```

### Using the request in the route handler

The original `request` is cascaded in the route handler function if you need to access to it.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler({}, async (ctx, req) => {
  console.log('integrity', req.integrity)
  return new Response(null, { status: 200 })
})
```

## Fair use note

Please note that if you're not using any of the proposed options in `createSafeRouteHandler` it means you're surely don't need it.

```tsx
// Calling üëáüèª
export const GET = createSafeRouteHandler({}, async () => {
  return new Response(null, { status: 200 })
})

// is equal to declare the route handler this way üëáüèª
export function GET() {
  return new Response(null, { status: 200 })
}
// excepts `createSafeRouteHandler` will provide by default a native error catching
// and will return a `500` response. That's the only advantage.
```

  </TabsContent>
  <TabsContent value='page-server-components'>

```tsx title="app/page.tsx"
import { object, string, number } from 'decoders'
import { unauthorized } from 'next/navigation'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'

export default createSafePageServerComponent(
  {
    authorize: async ({ segments }) => {
      const session = await auth.getSession()
      if (!session) {
        unauthorized()
      }

      return { user: session.user }
    },
    segments: {
      id: string,
    },
    searchParams: {
      page: number,
    },
  },
  async ({
    auth, // Auth context is inferred from the authorize function
    segments, // Segments are inferred from the segments validation
    searchParams, // Search params are inferred from the searchParams validation
  }) => {
    return <div>Hello {auth.user.name}!</div>
  }
)
```

## Framework validation agnostic

By design the factory is framework validation agnostic üåü. When doing your validations you can use whatever you want as framework validation as long as it implements the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface. You can use your favorite validation library like [Zod](https://zod.dev/), [Validbot](https://valibot.dev/) or [decoders](https://decoders.cc/).

```tsx title="app/races/[id]/page.tsx"
import { z } from 'zod'
import { string, number } from 'decoders'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent(
  {
    // `zod` for segments dictionary validation
    segments: { id: z.string() },
    // `decoders` for search params dictionary validation
    searchParams: {
      page: number,
    },
  },
  async ({ segments, searchParams }) => {
    return (
      <div>
        Race {segments.id} - Page {searchParams.page}
      </div>
    )
  }
)
```

## Synchronous validations

The factory do not supports async validations. As required by the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface we should avoid it. In the context of a server component it's not necessary.

If you define an async validation then the page server component will throw an error.

## API

Check the API and the available options to configure the factory as you wish üëáüèª

### Signature

```tsx title="node_modules/@sugardarius/anzen/server-components/index.d.ts"
import {
  type CreateSafePageServerComponentOptions,
  type SafePageServerComponentContext,
  createSafePageServerComponent
} from '@sugardarius/anzen/server-components'

/**
 * Returns a Next.js page server component function.
 */
export default createSafePageServerComponent(
  /**
   * Options to configure the page server component
   */
  options: CreateSafePageServerComponentOptions,
  /**
   * The page server component function.
   */
  async (
    /**
     * Context object providing:
     *  auth context
     *  validated segments and search params
     */
    ctx: SafePageServerComponentContext
  ): Promise<React.ReactElement> => <div>Hello</div>)
```

### Options

When creating a safe page server component you can use a bunch of options for helping you achieve different tasks üëáüèª

#### `id?: string`

Used for logging in development or when the `debug` option is enabled. You can also use it to add extra logging or monitoring.
By default the id is set to `[unknown:page:server:component]`.

```tsx title="app/races/[id]/page.tsx"
export default createSafePageServerComponent(
  {
    id: 'races/[id]/page',
  },
  async ({ id }) => {
    return <div>Page {id}</div>
  }
)
```

#### `onError?: (err: unknown) => Awaitable<never>`

Callback triggered when the pageserver component throws an unhandled error.
By default it rethrows the error as a service hatch to Next.js do its job and use error boundaries. The error is logged into the console.
Use it if you want to manage unexpected errors properly to log, trace or define behaviors like using `notFound` or `redirect`.

```tsx title="app/page.tsx"
import { notFound } from 'next/navigation'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent(
  {
    onError: async (err: unknown): Promise<never> => {
      if (err instanceof NotFoundError) {
        notFound()
      }
      throw err
    },
  },
  async () => {
    return <div>Hello</div>
  }
)
```

#### `debug?: boolean`

Use this options to enable debug mode. It will add logs in the page server component to help you debug the request.
By default it's set to `false` for production builds.
In development builds, it will be `true` if `NODE_ENV` is not set to `production`.

```tsx title="app/page.tsx"
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent({ debug: true }, async () => {
  return <div>Hello</div>
})
```

You can configure page server component options' validation using a validation library dynamic route segments and URL query parameters üëáüèª

#### `authorize?: PageAuthFunction<AC, TSegments, TSearchParams>`

Function to use to authorize the page server component. By default it always authorize the server component.

Return never (throws an error, `notFound`, `forbidden`, `unauthorized`, or `redirect`) when the request to the server component is not authorized.

The `authorize` function receives validated attributes (`segments`, `searchParams`) when they are defined, allowing you to use validated data for authorization logic.

**Parameters:**

- `id: string` - Server component ID
- `segments?:` - Validated route dynamic segments (if `segments` option is defined)
- `searchParams?:` - Validated search params (if `searchParams` option is defined)

###### Basic authorization

```tsx title="app/page.tsx"
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { unauthorized } from 'next/navigation'

export default createSafePageServerComponent(
  {
    authorize: async () => {
      const session = await auth.getSession()
      if (!session) {
        unauthorized()
      }

      return { user: session.user }
    },
  },
  async ({ auth }) => {
    return <div>Hello {auth.user.name}!</div>
  }
)
```

###### Authorization with validated segments

```tsx title="app/accounts/[accountId]/projects/[projectId]/page.tsx"
import { z } from 'zod'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { notFound } from 'next/navigation'

export default createSafePageServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string(),
    },
    authorize: async ({ segments }) => {
      // segments are already validated at this point
      const session = await auth.getSession()
      if (!session) {
        throw new Error('Unauthorized')
      }

      // Check if user has access to this account
      const hasAccess = await checkAccountAccess(
        session.user.id,
        segments.accountId
      )
      if (!hasAccess) {
        notFound()
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments }) => {
    return (
      <div>
        {auth.user.name} - {segments.accountId}/{segments.projectId}
      </div>
    )
  }
)
```

###### Authorization with validated search params

```tsx title="app/page.tsx"
import { z } from 'zod'
import { unauthorized } from 'next/navigation'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent(
  {
    searchParams: {
      code: z.string(),
    },
    authorize: async ({ searchParams }) => {
      // searchParams are already validated at this point
      const isValidCode = await validateCode(searchParams.code)
      if (!isValidCode) {
        unauthorized()
      }

      return { code: searchParams.code }
    },
  },
  async ({ auth, searchParams }) => {
    return <div>Code: {auth.code}</div>
  }
)
```

###### Authorization with all validated props

```tsx title="app/accounts/[accountId]/page.tsx"
import { z } from 'zod'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { notFound } from 'next/navigation'

export default createSafePageServerComponent(
  {
    segments: { accountId: z.string() },
    searchParams: { role: z.string() },
    authorize: async ({ segments, searchParams }) => {
      // All props are validated and available
      const session = await auth.getSession()
      if (!session) {
        throw new Error('Unauthorized')
      }

      const hasPermission = await checkPermission(
        session.user.id,
        segments.accountId,
        searchParams.role
      )
      if (!hasPermission) {
        notFound()
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments, searchParams }) => {
    return (
      <div>
        {auth.user.name} - {segments.accountId} - {searchParams.role}
      </div>
    )
  }
)
```

#### `segments?: TSegments`

[Dynamic route segments](https://nextjs.org/docs/app/api-reference/file-conventions/page#params) used for the page server component path. By design it will handle automatically if the segments are a `Promise` or not.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="app/accounts/[accountId]/projects/[projectId]/page.tsx"
import { z } from 'zod'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
  },
  async ({ segments }) => {
    return (
      <div>
        Account: {segments.accountId} - Project: {segments.projectId}
      </div>
    )
  }
)
```

#### `onSegmentsValidationError?: OnValidationError`

Callback triggered when dynamic segments validations returned issues. By default it throws a `ValidationError` and issues are logged into the console.

```tsx title="app/accounts/[accountId]/projects/[projectId]/page.tsx"
import { z } from 'zod'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { notFound } from 'next/navigation'

export default createSafePageServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
    onSegmentsValidationError: async (issues) => {
      console.error('Invalid segments', issues)
      notFound()
    },
  },
  async ({ segments }) => {
    return (
      <div>
        Account: {segments.accountId} - Project: {segments.projectId}
      </div>
    )
  }
)
```

#### `searchParams?: TSearchParams`

Search params used in the page.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="app/search/page.tsx"
import { string, numeric, optional } from 'decoders'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'

export default createSafePageServerComponent(
  {
    searchParams: {
      query: string,
      page: optional(numeric),
    },
  },
  async ({ searchParams }) => {
    return (
      <div>
        Query: {searchParams.query} - Page: {searchParams.page}
      </div>
    )
  }
)
```

#### `onSearchParamsValidationError?: OnValidationError`

Callback triggered when search params validations returned issues. By default it throws a `ValidationError` and issues are logged into the console.

```tsx title="app/search/page.tsx"
import { string, numeric, optional } from 'decoders'
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { redirect } from 'next/navigation'

export default createSafePageServerComponent(
  {
    searchParams: {
      query: string,
      page: optional(numeric),
    },
    onSearchParamsValidationError: async (issues) => {
      console.error('Invalid search params', issues)
      redirect('/')
    },
  },
  async ({ searchParams }) => {
    return (
      <div>
        Query: {searchParams.query} - Page: {searchParams.page}
      </div>
    )
  }
)
```

### Error handling

By design the factory will catch any error thrown in the page server component and rethrow it by default to let Next.js handle it with error boundaries.

<Callout>
  **Note:** Next.js native errors (`redirect`, `notFound`, `forbidden`,
  `unauthorized`) are silent (e.g not logged). These errors are part of
  Next.js's control flow and are expected behavior, so they won't clutter your
  logs.
</Callout>

You can customize the error handling if you want to fine tune error management.

```tsx title="app/page.tsx"
import { createSafePageServerComponent } from '@sugardarius/anzen/server-components'
import { NotFoundError, DbUnknownError } from '~/lib/errors'
import { db } from '~/lib/db'
import { notFound } from 'next/navigation'

export default createSafePageServerComponent(
  {
    onError: async (err: unknown): Promise<never> => {
      // Take it as an example not as a real use case üòÖ
      if (err instanceof NotFoundError) {
        notFound()
      } else if (err instanceof DbUnknownError) {
        console.error('Database error', err)
        throw err
      }

      throw err
    },
  },
  async () => {
    const [data, err] = await db.findUnique({ id: 'liveblocks' })

    if (err) {
      throw new DbUnknownError(err.message, 500)
    }

    if (data === null) {
      throw new NotFoundError()
    }

    return <div>{data.name}</div>
  }
)
```

## Fair use note

Please note that if you're not using any of the proposed options in `createSafePageServerComponent` it means you're surely don't need it.

```tsx title="app/page.tsx"
// Calling üëáüèª
export default createSafePageServerComponent({}, async () => {
  return <div>Hello</div>
})

// is equal to declare the page server component this way üëáüèª
export default async function Page() {
  return <div>Hello</div>
}
```

</TabsContent>
<TabsContent value='layout-server-components'>

```tsx title="app/layout.tsx"
import { object, string, number } from 'decoders'
import { unauthorized } from 'next/navigation'
import { createSafePageLayoutComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'

export default createSafePageLayoutComponent(
  {
    authorize: async ({ segments }) => {
      const session = await auth.getSession()
      if (!session) {
        unauthorized()
      }

      return { user: session.user }
    },
    segments: {
      id: string,
    },
  },
  async ({
    auth, // Auth context is inferred from the authorize function
    segments, // Segments are inferred from the segments validation
    children,
  }) => {
    return (
      <main>
        <header>Hello {auth.user.name}!</header>
        {children}
      </main>
    )
  }
)
```

## Framework validation agnostic

By design the factory is framework validation agnostic üåü. When doing your validations you can use whatever you want as framework validation as long as it implements the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface. You can use your favorite validation library like [Zod](https://zod.dev/), [Validbot](https://valibot.dev/) or [decoders](https://decoders.cc/).

```tsx title="app/races/[id]/layout.tsx"
import { z } from 'zod'
import { string } from 'decoders'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent(
  {
    // `zod` for segments dictionary validation
    segments: { id: z.string() },
  },
  async ({ segments, children }) => {
    return (
      <div>
        Race {segments.id}
        {children}
      </div>
    )
  }
)
```

## Synchronous validations

The factory do not supports async validations. As required by the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface we should avoid it. In the context of a server component it's not necessary.

If you define an async validation then the layout server component will throw an error.

## API

Check the API and the available options to configure the factory as you wish üëáüèª

### Signature

```tsx title="node_modules/@sugardarius/anzen/server-components/index.d.ts"
import {
  type CreateSafeLayoutServerComponentOptions,
  type SafeLayoutServerComponentContext,
  createSafeLayoutServerComponent
} from '@sugardarius/anzen/server-components'

/**
 * Returns a Next.js layout server component function.
 */
export default createSafeLayoutServerComponent(
  /**
   * Options to configure the layout server component
   */
  options: CreateSafeLayoutServerComponentOptions,
  /**
   * The layout server component function.
   */
  async (
    /**
     * Context object providing:
     *  auth context
     *  validated segments
     *  children
     */
    ctx: SafeLayoutServerComponentContext
  ): Promise<React.ReactElement> => <div>{children}</div>)
```

### Options

When creating a safe layout server component you can use a bunch of options for helping you achieve different tasks üëáüèª

#### `id?: string`

Used for logging in development or when the `debug` option is enabled. You can also use it to add extra logging or monitoring.
By default the id is set to `[unknown:layout:server:component]`.

```tsx title="app/races/[id]/layout.tsx"
export default createSafeLayoutServerComponent(
  {
    id: 'races/[id]/layout',
  },
  async ({ id }) => {
    return <div>Layout {id}</div>
  }
)
```

#### `onError?: (err: unknown) => Awaitable<never>`

Callback triggered when the layout server component throws an unhandled error.
By default it rethrows the error as a service hatch to Next.js do its job and use error boundaries. The error is logged into the console.
Use it if you want to manage unexpected errors properly to log, trace or define behaviors like using `notFound` or `redirect`.

```tsx title="app/layout.tsx"
import { notFound } from 'next/navigation'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent(
  {
    onError: async (err: unknown): Promise<never> => {
      if (err instanceof NotFoundError) {
        notFound()
      }
      throw err
    },
  },
  async () => {
    return <div>Hello</div>
  }
)
```

#### `debug?: boolean`

Use this options to enable debug mode. It will add logs in the layout server component to help you debug the request.
By default it's set to `false` for production builds.
In development builds, it will be `true` if `NODE_ENV` is not set to `production`.

```tsx title="app/layout.tsx"
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent({ debug: true }, async () => {
  return <div>Hello</div>
})
```

Layout server components support the same options as page server components except `searchParams` and `onSearchParamsValidationError`. Additionally, layout server components receive `children` in their context.

#### `authorize?: LayoutAuthFunction<AC, TSegments>` (Layout only)

Function to use to authorize the layout server component. By default it always authorize the server component.

Return never (throws an error, `notFound`, `forbidden`, `unauthorized`, or `redirect`) when the request to the server component is not authorized.

The `authorize` function receives validated attributes (`segments`) when they are defined, allowing you to use validated data for authorization logic.

**Parameters:**

- `id: string` - Server component ID
- `segments?:` - Validated route dynamic segments (if `segments` option is defined)

```tsx title="app/accounts/[accountId]/layout.tsx"
import { z } from 'zod'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { notFound, unauthorized } from 'next/navigation'

export default createSafeLayoutServerComponent(
  {
    segments: {
      accountId: z.string(),
    },
    authorize: async ({ segments }) => {
      const session = await auth.getSession()
      if (!session) {
        unauthorized()
      }

      const hasAccess = await checkAccountAccess(
        session.user.id,
        segments.accountId
      )
      if (!hasAccess) {
        notFound()
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments, children }) => {
    return (
      <div>
        <header>Account: {segments.accountId}</header>
        {children}
      </div>
    )
  }
)
```

You can configure layout server component options' validation using a validation library dynamic route segments üëáüèª

#### `authorize?: LayoutAuthFunction<AC, TSegments>`

Function to use to authorize the layout server component. By default it always authorize the layout server component.

Return never (throws an error, `notFound`, `forbidden`, `unauthorized`, or `redirect`) when the request to the server component is not authorized.

The `authorize` function receives validated attribute (`segments``) when they are defined, allowing you to use validated data for authorization logic.

**Parameters:**

- `id: string` - Server component ID
- `segments?:` - Validated route dynamic segments (if `segments` option is defined)

###### Basic authorization

```tsx title="app/layout.tsx"
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { unauthorized } from 'next/navigation'

export default createSafeLayoutServerComponent(
  {
    authorize: async () => {
      const session = await auth.getSession()
      if (!session) {
        unauthorized()
      }

      return { user: session.user }
    },
  },
  async ({ auth }) => {
    return <div>Hello {auth.user.name}!</div>
  }
)
```

###### Authorization with validated segments

```tsx title="app/accounts/[accountId]/projects/[projectId]/layout.tsx"
import { z } from 'zod'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'
import { auth } from '~/lib/auth'
import { notFound } from 'next/navigation'

export default createSafeLayoutServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string(),
    },
    authorize: async ({ segments }) => {
      // segments are already validated at this point
      const session = await auth.getSession()
      if (!session) {
        throw new Error('Unauthorized')
      }

      // Check if user has access to this account
      const hasAccess = await checkAccountAccess(
        session.user.id,
        segments.accountId
      )
      if (!hasAccess) {
        notFound()
      }

      return { user: session.user }
    },
  },
  async ({ auth, segments }) => {
    return (
      <div>
        {auth.user.name} - {segments.accountId}/{segments.projectId}
      </div>
    )
  }
)
```

#### `segments?: TSegments`

[Dynamic route segments](https://nextjs.org/docs/app/api-reference/file-conventions/layout#params) used for the layout server component path. By design it will handle automatically if the segments are a `Promise` or not.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="app/accounts/[accountId]/projects/[projectId]/layout.tsx"
import { z } from 'zod'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
  },
  async ({ segments }) => {
    return (
      <div>
        Account: {segments.accountId} - Project: {segments.projectId}
      </div>
    )
  }
)
```

#### `onSegmentsValidationError?: OnValidationError`

Callback triggered when dynamic segments validations returned issues. By default it throws a `ValidationError` and issues are logged into the console.

```tsx title="app/accounts/[accountId]/projects/[projectId]/layout.tsx"
import { z } from 'zod'
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'
import { notFound } from 'next/navigation'

export default createSafeLayoutServerComponent(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
    onSegmentsValidationError: async (issues) => {
      console.error('Invalid segments', issues)
      notFound()
    },
  },
  async ({ segments }) => {
    return (
      <div>
        Account: {segments.accountId} - Project: {segments.projectId}
      </div>
    )
  }
)
```

#### üß™ `experimental_slots?: string[]`

Slots used in the layout when using [Next.js parallel routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes) (experimental).

When defined, the slots are provided in the context as `experimental_slots` with the slot names as keys and `React.ReactNode` as values. The factory validates that all expected slots are provided and throws a `MissingLayoutSlotsError` if any slots are missing.

```tsx title="app/dashboard/layout.tsx"
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent(
  {
    experimental_slots: ['analytics', 'team'] as const,
    //                                           ^^^^^üëÜüèª
    //                                           Required for proper type inference
  },
  async ({ children, experimental_slots }) => {
    return (
      <div>
        <aside>
          {experimental_slots.analytics ?? (
            <div>Analytics slot: No matching route</div>
          )}
        </aside>
        <main>{children}</main>
        <footer>
          {experimental_slots.team ?? <div>Team slot: No matching route</div>}
        </footer>
      </div>
    )
  }
)
```

<Callout>
**Why `as const` is required?**

The `as const` assertion is necessary for proper type inference because Next.js generates explicit types for parallel route slots at build time.
Next.js typegen creates a `LayoutSlotMap` interface in `.next/types/routes.d.ts` that maps each route to its slot names as a union type (e.g., `"/playground/parallel": "analytics" | "team"`).

The `LayoutProps` from `createSafeLayoutServerComponent` needs to stick to the Next.js typing requirements for build time.

Without `as const`, TypeScript will infer the option `experimental_slots` as an index signature like `{[x: string]: React.ReactNode}` instead of an explicit signature as expected by Next.js
This prevents the type system from matching the exact slot names that Next.js expects, breaking type safety, and build.

</Callout>

### Using children in layout server components

The `children` prop is automatically provided in the context for layout server components.

```tsx title="app/layout.tsx"
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'

export default createSafeLayoutServerComponent({}, async ({ children }) => {
  return (
    <div>
      <header>Header</header>
      <main>{children}</main>
      <footer>Footer</footer>
    </div>
  )
})
```

### Error handling

By design the factory will catch any error thrown in the layout server component and rethrow it by default to let Next.js handle it with error boundaries.

<Callout>
  **Note:** Next.js native errors (`redirect`, `notFound`, `forbidden`,
  `unauthorized`) are silent (e.g not logged). These errors are part of
  Next.js's control flow and are expected behavior, so they won't clutter your
  logs.
</Callout>

You can customize the error handling if you want to fine tune error management.

```tsx title="app/layout.tsx"
import { createSafeLayoutServerComponent } from '@sugardarius/anzen/server-components'
import { NotFoundError, DbUnknownError } from '~/lib/errors'
import { db } from '~/lib/db'
import { notFound } from 'next/navigation'

export default createSafeLayoutServerComponent(
  {
    onError: async (err: unknown): Promise<never> => {
      // Take it as an example not as a real use case üòÖ
      if (err instanceof NotFoundError) {
        notFound()
      } else if (err instanceof DbUnknownError) {
        console.error('Database error', err)
        throw err
      }

      throw err
    },
  },
  async ({ children }) => {
    const [data, err] = await db.findUnique({ id: 'liveblocks' })

    if (err) {
      throw new DbUnknownError(err.message, 500)
    }

    if (data === null) {
      throw new NotFoundError()
    }

    return (
      <main>
        <header>{data.name}</header>
        {children}
      </main>
    )
  }
)
```

## Fair use note

Please note that if you're not using any of the proposed options `createSafeLayoutServerComponent` it means you're surely don't need it.

```tsx title="app/layout.tsx"
// Calling üëáüèª
export default createSafeLayoutServerComponent({}, async ({ children }) => {
  return <div>{children}</div>
})

// is equal to declare the layout server component this way üëáüèª
export default async function Layout({
  children,
}: {
  children: React.ReactNode
}) {
  return <div>{children}</div>
}
```

  </TabsContent>
</Tabs>

Feel free to open an issue or a PR if you think a relevant option could be added into the factory üôÇ

## Requirements

The factories requires Next.js `v14`, `v15` or `v16` as peer dependencies.

## Credits

Thanks to [@t3-oss/env-core](https://github.com/t3-oss/t3-env) for opening the implementation of `StandardSchemaDictionary` üôèüèª
