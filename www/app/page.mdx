<Highlight>
  A flexible, framework validation agnostic, type-safe factory for creating
  [Next.JS App Router route
  handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers).
</Highlight>

```tsx
import { object, string, number } from 'decoders'
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const POST = createSafeRouteHandler(
  {
    authorize: async ({ req }) => {
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
    body: object({
      foo: string,
      bar: number,
    }),
  },
  async (
    {
      auth, // Auth context is inferred from the authorize function
      body, // Body is inferred from the body validation
    },
    req
  ): Promise<Response> => {
    return Response.json({ user: auth.user, body }, { status: 200 })
  }
)
```

- ðŸ”§ Framework validation agnostic, use a validation library of your choice supporting [Standard Schema](https://standardschema.dev/).
- ðŸ§  Focused functionalities, use only features you want.
- ðŸ§¹ Clean and flexible API.
- ðŸ”’ Type-safe.
- ðŸŒ± Dependency free.
- ðŸª¶ Less than 100kB unpacked.

## Install

```sh
npm i @sugardarius/anzen
```

## Framework validation agnostic

By design the factory is framework validation agnostic ðŸŒŸ. When doing your validations you can use whatever you want as framework validation as long as it implements the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface. You can use your favorite validation library like [Zod](https://zod.dev/) or [decoders](https://decoders.cc/).

```tsx
// (POST) /app/api/races/[id]/route.ts
import { z } from 'zod'
import { object, string, number } from 'decoders'

export const POST = createSafeRouteHandler(
  {
    // `zod` for segments dictionary validation
    segments: { id: z.string() }
    // `decoders` for body object validation
    body: object({
      id: number,
      name: string,
    }),
  },
  async ({ segments, body }) => {
    return Response.json({ segments, body })
  }
)
```

## Synchronous validations

The factory do not supports async validations. As required by the [Standard Schema](https://github.com/standard-schema/standard-schema) common interface we should avoid it. In the context of a route handler it's not necessary.

If you define an async validation then the route handler will throw an error.

## API

Check the API and the available options to configure the factory as you wish.

### Base options

When creating a safe route handler you can use a bunch of options for helping you achieve different tasks ðŸ‘‡ðŸ»

#### `id?: string`

Used for logging in development or when the `debug` option is enabled. You can also use it to add extra logging or monitoring.
By default the id is set to `[unknown:route:handler]`.

```tsx
export const POST = createSafeRouteHandler(
  {
    id: 'my-safe-route-handler',
  },
  async ({ id }) => {
    return Response.json({ id })
  }
)
```

#### `authorize?: AuthFunction<AC>`

Function to use to authorize the request. By default it always authorize the request.
Returns a response when the request is not authorized.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'
import { auth } from '~/lib/auth'

export const GET = createSafeRouteHandler(
  {
    authorize: async ({ req, url }) => {
      console.log('url', url)
      const session = await auth.getSession(req)
      if (!session) {
        return new Response(null, { status: 401 })
      }

      return { user: session.user }
    },
  },
  async ({ auth, body }, req): Promise<Response> => {
    return Response.json({ user: auth.user }, { status: 200 })
  }
)
```

#### `onErrorResponse?: (err: unknown) => Awaitable<Response>`

Callback triggered when the request fails.
By default it returns a simple `500` response and the error is logged into the console.
Use it if your handler use custom errors and you want to manage them properly by returning a proper response.
You can read more about it under the [Error handling](#error-handling) section.

#### `debug?: boolean`

Use this options to enable debug mode. It will add logs in the handler to help you debug the request.
By default it's set to `false` for production builds.
In development builds, it will be `true` if `NODE_ENV` is not set to `production`.

```tsx
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler({ debug: true }, async () => {
  return new Response(null, { status: 200 })
})
```

### Route handler options

You can configure route handler options to validation using a validation library dynamic route segments, URL query parameters, request json body or request form data body ðŸ‘‡ðŸ»

#### `segments?: TSegments`

[Dynamic route segments](https://nextjs.org/docs/app/building-your-application/routing/route-handlers#dynamic-route-segments) used for the route handler path. By design it will handle if the segments are a `Promise` or not.

Please note the expected input is a `StandardSchemaDictionary`.

```tsx title="/api/accounts/[accountId]/projects/[projectId]/route.ts"
import { z } from 'zod'
import { createSafeRouteHandler } from '@sugardarius/anzen'

export const GET = createSafeRouteHandler(
  {
    segments: {
      accountId: z.string(),
      projectId: z.string().optional(),
    },
  },
  async ({ segments }) => {
    return Response.json({ segments })
  }
)
```
